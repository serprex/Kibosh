#!/usr/bin/python
from __future__ import division
import pyglet
from pyglet.gl import *
from socket import *
from math import sin,cos,pi
from select import select
from itertools import count
try:
	range=xrange
	from itertools import imap as map,izip as zip,ifilter as filter
	getnext=lambda x:x.next
except:
	cmp=lambda x,y:(x>y)or-(x<y)
	getnext=lambda x:x.__next__
globals().update((lambda a,b:(a,(int(b) if b.isdigit() else b)))(*a.split()) for a in open("Kibosh."))
socket.check=lambda s,x=0:select((s,),(),(),x)[0]
tcp=socket(AF_INET,SOCK_STREAM)
tcp.setsockopt(IPPROTO_TCP,TCP_NODELAY,1)
if len(__import__("sys").argv)==2:
	tcp.bind(("",port))
	tcp.listen(1)
	tcp=tcp.accept()[0]
	tcp.send(chr(blue))
else:
	tcp.connect((host,port))
	blue=not ord(tcp.recv(1))
pyglet.clock.set_fps_limit(30)
W=pyglet.window.Window(width=320,height=512)
W.set_location(100+600*blue,100)
glEnable(GL_BLEND)
glBlendFunc(GL_SRC_ALPHA,GL_ONE)
awds=[0,0,0,0]
awds2=0,0,0,0
if blue:
	X1,Y1=80,160
	X2,Y2=240,320
else:
	X1,Y1=240,320
	X2,Y2=80,160
X0=Y0=Z0=.5
hit=E1=E2=T=0
life=3
B=[]
nbid=getnext(count())
def Bxyd(p,x,y,d,v):
	global B
	B+=[p,x,y,sin(d)*v,cos(d)*v,nbid()&1023],
def miss():
	global hit,awds2,life
	if not life:"dead"
	hit=1
	awds2=0,0,0,0
	life-=1
@W.event
def on_key_press(k,m):
	if 65360<k<65365:
		awds[k-65361]=1
		tcp.send(chr(0xF0|awds[0]|awds[1]<<1|awds[2]<<2|awds[3]<<3))
	elif k=="Z":"shoot"
@W.event
def on_key_release(k,m):
	if 65360<k<65365:
		awds[k-65361]=0
		tcp.send(chr(0xF0|awds[0]|awds[1]<<1|awds[2]<<2|awds[3]<<3)+("" if any(awds) else "%c%c%c"%(X1>>8|Y1>>8<<1,X1&255,Y1&255)))
while not W.has_exit:
	W.dispatch_events()
	if hit:awds=[0,0,0,0]
	if not T&31:tcp.send("%c%c%c"%(X1>>8|Y1>>8<<1,X1&255,Y1&255))
	if awds[2]-awds[0] and awds[1]-awds[3]:
		X1+=(awds[2]-awds[0]<<2)*3>>2
		Y1+=(awds[1]-awds[3]<<2)*3>>2
	else:
		X1+=awds[2]-awds[0]<<2
		Y1+=awds[1]-awds[3]<<2
	if X1<0:X1=0
	elif X1>320:X1=320
	if Y1<0:Y1=0
	elif Y1>511:Y1=511
	while tcp.check():
		r=ord(tcp.recv(1))
		if r&0xF0==0xF0:
			if not hit:awds2=r&1,r>>1&1,r>>2&1,r>>3&1
		elif not r&0xFC:
			X2=ord(tcp.recv(1))|(r&1)<<8
			Y2=ord(tcp.recv(1))|(r&2)<<7
		elif r&0xF0==0x40:
			E2+=1
			c=r&7|ord(tcp.recv(1))<<3
			for a,b in enumerate(B):
				if b[5]==c:
					del B[a]
					break
		elif r==0xE0:miss()
		elif r==0xEF:exit()
	if awds2[2]-awds2[0] and awds2[1]-awds2[3]:
		X2+=(awds2[2]-awds2[0]<<2)*3>>2
		Y2+=(awds2[1]-awds2[3]<<2)*3>>2
	else:
		X2+=awds2[2]-awds2[0]<<2
		Y2+=awds2[1]-awds2[3]<<2
	if X2<0:X2=0
	elif X2>320:X2=320
	if Y2<0:Y2=0
	elif Y2>511:Y2=511
	Z0+=(Y1-Y2)/((X1-X2)**2+(Y1-Y2)**2+1)**.5
	if Z0<0.:Z0=0.
	elif Z0>1.:Z0=1.
	X0=X1+(X2-X1)*Z0
	Y0=Y1+(Y2-Y1)*Z0
	if hit:
		X1-=cmp(X1,160)<<4
		Y1-=cmp(Y1,256)<<4
		X2-=cmp(X2,160)<<4
		Y2-=cmp(Y2,256)<<4
		if -24<X1-160<24:X1=160
		if -24<Y1-256<24:Y1=256
		if -24<X2-160<24:X2=160
		if -24<Y2-256<24:Y2=256
		if 256==Y1==Y2 and 160==X1==X2:hit=0
		B=[]
	glBegin(GL_QUADS)
	for a,b in zip(count(1),reversed(B)):
		glColor3f(b[0]==1,b[0]==2,not b[0])
		glVertex2f(b[1]+3,b[2])
		glVertex2f(b[1],b[2]+3)
		glVertex2f(b[1]-3,b[2])
		glVertex2f(b[1],b[2]-3)
		b[1]+=b[3]
		b[2]+=b[4]
		glVertex2f(b[1]+6,b[2])
		glVertex2f(b[1],b[2]+6)
		glVertex2f(b[1]-6,b[2])
		glVertex2f(b[1],b[2]-6)
		if -12<b[0]-X0<12 or -12<b[1]-Y0<12:
			if not Z0 and b[0]==blue or Z0==1 and b[0]==1-blue:
				tcp.send("\xE0")
				miss()
			else:
				tcp.send("%c%c"%(0x40|b[5]&7,b[5]>>3))
				del B[-a]
				E1+=1
	glEnd()
	glBegin(GL_TRIANGLE_FAN)
	glColor3f(0.,0.,0.)
	glVertex2i(X1,Y1)
	glColor3f(not blue,0.,blue)
	for a in range(7):
		glVertex2f(X1+cos(a*pi/3+T)*24.,Y1+sin(a*pi/3+T)*24.)
	glEnd()
	glBegin(GL_LINES)
	glVertex2i(X1,Y1)
	glColor3f(blue,0.,not blue)
	glVertex2i(X2,Y2)
	glEnd()
	glBegin(GL_TRIANGLE_FAN)
	glColor3f(0.,0.,0.)
	glVertex2i(X2,Y2)
	glColor3f(blue,0.,not blue)
	for a in range(7):
		glVertex2f(X2+cos(a*pi/3-T)*24.,Y2+sin(a*pi/3-T)*24.)
	glEnd()
	glColor3f(1.,1.,1.)
	glBegin(GL_TRIANGLE_FAN)
	glVertex2f(X0,Y0)
	glColor4f(0.,0.,0.,0.)
	for a in range(7):
		glVertex2f(X0+cos(a*pi/3-T)*24.,Y0+sin(a*pi/3+T)*24.)
	glEnd()
	W.flip()
	glClear(GL_COLOR_BUFFER_BIT)
	T+=1
	pyglet.clock.tick()
tcp.send("\xEF")
