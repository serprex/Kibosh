#!/usr/bin/python
from __future__ import division
import pyglet
from pyglet.gl import *
from socket import *
from math import sin,cos,pi
from select import select
from itertools import count
try:
	range=xrange
	from itertools import imap as map,izip as zip,ifilter as filter
	getnext=lambda x:x.next
except:
	cmp=lambda x,y:(x>y)or-(x<y)
	getnext=lambda x:x.__next__
globals().update((lambda a,b:(a,(int(b) if b.isdigit() else b)))(*a.split()) for a in open("Kibosh."))
socket.check=lambda s,x=0:select((s,),(),(),x)[0]
tcp=socket(AF_INET,SOCK_STREAM)
tcp.setsockopt(IPPROTO_TCP,TCP_NODELAY,1)
if len(__import__("sys").argv)==2:
	tcp.bind(("",port))
	tcp.listen(1)
	tcp=tcp.accept()[0]
	tcp.send(chr(blue))
else:
	tcp.connect((host,port))
	blue=not ord(tcp.recv(1))
pyglet.clock.set_fps_limit(30)
W=pyglet.window.Window(width=320,height=600)
W.set_location(100+600*blue,100)
glEnable(GL_BLEND)
glBlendFunc(GL_SRC_ALPHA,GL_ONE)
class Node:
	def __init__(s,x,y,b):
		s.x=x
		s.y=y
		s.b=b
		s.awds=[0,0,0,0]
	def move(s):
		if hit:return
		if s.awds[2]-s.awds[0] and s.awds[1]-s.awds[3]:
			s.x+=(s.awds[2]-s.awds[0]<<2)*3>>2
			s.y+=(s.awds[1]-s.awds[3]<<2)*3>>2
		else:
			s.x+=s.awds[2]-s.awds[0]<<2
			s.y+=s.awds[1]-s.awds[3]<<2
		if s.x<0:s.x=0
		elif s.x>320:s.x=320
		if s.y<0:s.y=0
		elif s.y>511:s.y=511
	def draw(s):
		glBegin(GL_TRIANGLE_FAN)
		glColor3f(0.,0.,0.)
		glVertex2i(s.x,s.y)
		glColor3f(not s.b,0.,s.b)
		for a in range(7):
			glVertex2f(s.x+cos(a*pi/3+T)*24.,s.y+sin(a*pi/3+T)*24.)
		glEnd()
	def hit(s):
		s.x-=cmp(s.x,160)<<4
		s.y-=cmp(s.y,256)<<4
		if -24<s.x-160<24:s.x=160
		if -24<s.y-256<24:s.y=256
if blue:
	N1=Node(80,160,1)
	N2=Node(240,320,0)
else:
	N1=Node(240,320,0)
	N2=Node(80,160,1)
X0=Y0=Z0=.5
hit=E1=E2=T=0
life=3
B=[]
nbid=getnext(count())
def Bxyd(p,x,y,d,v):
	global B
	B+=[p,x,y,sin(d)*v,cos(d)*v,nbid()&1023],
def miss():
	global hit,life
	if not life:"dead"
	hit=1
	life-=1
@W.event
def on_key_press(k,m):
	if 65360<k<65365:
		N1.awds[k-65361]=1
		tcp.send("%c%c%c"%(0xF0|N1.awds[0]|N1.awds[1]<<1|N1.awds[2]<<2|N1.awds[3]<<3,N1.x>>1,N1.y>>1))
	elif k=="Z":"shoot"
@W.event
def on_key_release(k,m):
	if 65360<k<65365:
		N1.awds[k-65361]=0
		tcp.send("%c%c%c"%(0xF0|N1.awds[0]|N1.awds[1]<<1|N1.awds[2]<<2|N1.awds[3]<<3,N1.x>>1,N1.y>>1))
while not W.has_exit:
	W.dispatch_events()
	N1.move()
	while tcp.check():
		r=ord(tcp.recv(1))
		if r&0xF0==0xF0:
			N2.awds=r&1,r>>1&1,r>>2&1,r>>3&1
			N2.x=ord(tcp.recv(1))<<1
			N2.y=ord(tcp.recv(1))<<1
		elif r&0xF0==0x40:
			E2+=1
			c=r&7|ord(tcp.recv(1))<<3
			for a,b in enumerate(B):
				if b[5]==c:
					del B[a]
					break
		elif r==0xE0:miss()
		elif r==0xEF:exit()
	N2.move()
	Z0+=(N1.y-N2.y)/((N1.x-N2.x)**2+(N1.y-N2.y)**2+1)**.5
	if Z0<0.:Z0=0.
	elif Z0>1.:Z0=1.
	X0=N1.x+(N2.x-N1.x)*Z0
	Y0=N1.y+(N2.y-N1.y)*Z0
	if hit:
		N1.hit()
		N2.hit()
		hit=not(256==N1.y==N2.y and 160==N1.x==N2.x)
		B=[]
	glBegin(GL_QUADS)
	for a,b in zip(count(1),reversed(B)):
		glColor3f(not b[0],b[0]==2,b[0]==1)
		glVertex2f(b[1]+3,b[2])
		glVertex2f(b[1],b[2]+3)
		glVertex2f(b[1]-3,b[2])
		glVertex2f(b[1],b[2]-3)
		b[1]+=b[3]
		b[2]+=b[4]
		glVertex2f(b[1]+6,b[2])
		glVertex2f(b[1],b[2]+6)
		glVertex2f(b[1]-6,b[2])
		glVertex2f(b[1],b[2]-6)
		if -12<b[0]-X0<12 or -12<b[1]-Y0<12:
			if not Z0 and b[0]==blue or Z0==1 and b[0]==1-blue:
				tcp.send("\xE0")
				miss()
			else:
				tcp.send("%c%c"%(0x40|b[5]&7,b[5]>>3))
				del B[-a]
				E1+=1
	glEnd()
	N1.draw()
	glBegin(GL_LINES)
	glVertex2i(N1.x,N1.y)
	glColor3f(blue,0.,not blue)
	glVertex2i(N2.x,N2.y)
	glEnd()
	N2.draw()
	glColor3f(1.,1.,1.)
	glBegin(GL_TRIANGLE_FAN)
	glVertex2f(X0,Y0)
	glColor4f(0.,0.,0.,0.)
	for a in range(7):
		glVertex2f(X0+cos(a*pi/3-T)*24.,Y0+sin(a*pi/3+T)*24.)
	glEnd()
	W.flip()
	glClear(GL_COLOR_BUFFER_BIT)
	T+=1
	pyglet.clock.tick()
tcp.send("\xEF")
