#!/usr/bin/python
from __future__ import division
from pyglet import *
options["debug_gl"]=False
from pyglet.gl import *
from socket import *
from math import *
from select import select
from itertools import count,chain,cycle
from random import getrandbits
from collections import defaultdict
try:
	range=xrange
	from itertools import imap as map,izip as zip,ifilter as filter
	getnext=lambda x:x.next
except:
	cmp=lambda x,y:(x>y)or-(x<y)
	getnext=lambda x:x.__next__
for a in range(1,16):globals().update(("pi%X%X"%(a,b),pi*a/b) for b in range(1,16))
pi63v=0,pi13,pi23,pi33,pi43,pi53,pi63
def sin1(x,v=list(map(sin,range(377)))):return v[x%377]
def cos1(x,v=list(map(cos,range(377)))):return v[x%377]
GLB3=GLubyte*3
Red,Blu,Gre=RGB=GLB3(255,0,0),GLB3(0,0,255),GLB3(0,255,0)
Blk,Wht,Blk=BWB=((GLB3(0,0,0),GLB3(255,255,255))*2)[:3]
def ptdir(x,y,m):
	y=y%pi21-x%pi21
	return max(-m,y) if y%pi21>pi else min(m,y)
def Bul(p,x,y,d,v):return Bad([p,x,y,cos(d)*v,sin(d)*v])
def miss():
	global hit,life,E
	if not hit:
		if not life:print "dead"
		E=0
		hit=1
		life-=1
def atch():
	global E
	send("\xE2\xE3"[E==14])
	E+=1
	if E==15:
		Nut(N1,0)
		E=0
def near(x,y):return min(chain((((a.x-x)**2+(a.y-y)**2,a,a is N1) for a in NN),((((a[1][-1][0]-x)**2+(a[1][-1][1]-y)**2,a,a[2]) for a in N if a[0] is not None))))
def msg(x,y=""):
	M[x]=y
	send("%c%c%s"%(0xC0|len(y),x,y))
def on_key(k,o):
	if 65360<k<65365:
		N1.awds[k-65361]=o
		send("%c%c%c"%(0xF0|N1.awds[0]|N1.awds[1]<<1|N1.awds[2]<<2|N1.awds[3]<<3,N1.x>>1,N1.y>>1))
	elif k==65307:app.exit()
W=window.Window(360,512,visible=False,vsync=False)
W.on_key_press=lambda k,m:on_key(k,1)
W.on_key_release=lambda k,m:on_key(k,0)
W.idle=W.dispatch_events
glEnable(GL_BLEND)
X0=Y0=Z0=.5
Nap=T=Tlc=E=hit=hit2=0
life=3
M={}
Tl=[]
N=[]
B=[]
Bad=B.append
class Node:
	def __init__(s,*x):
		s.x,s.y,s.p=x
		s.awds=[0,0,0,0]
class F:
	def __init__(s):
		s.F={}
		s.__iter__=s.F.__iter__
		s.__getitem__=s.F.__getitem__
		s.__contains__=s.F.__contains__
		s.R=[]
		s.__delitem__=s.R.append
		s._F={}
		s.f=getnext(count())
	def __call__(s,x):
		s._F[s.f()&4095]=x
		return x
class Cannon:
	die=lambda s:not Fd.add(Cannond(s))
	def __init__(s,p,x,y,d,v,t,D=None,V=3):
		s.p=p
		s.x=x
		s.y=y
		s.h=cos(d)*v
		s.v=sin(d)*v
		s.t=t
		s.d=d if D is None else D
		s.V=V
		s.T=0
	def __call__(s):
		s.T+=1
		s.x+=s.h
		s.y+=s.v
		s.d+=ptdir(s.d,atan2(Y0-s.y,X0-s.x),pi1F)
		if not(-32<s.x<392 and -32<s.y<544):return send
		a=near(s.x,s.y)
		if a[0]<400 and a[2]:
			if a[1] is N1 and N1.p==s.p:Nut()
			return s.die()
		ct=cos1(s.T)*16.
		st=sin1(s.T)*16.
		if not s.T%s.t:Bul(s.p,s.x+ct,s.y+st,s.d,s.V)
		return s.draw(24.,ct,st)
	def draw(s,r,ct,st):
		glColor3ubv(RGB[s.p])
		for a in GL_QUADS,GL_LINE_LOOP:
			glBegin(a)
			glVertex2f(s.x+ct,s.y+st)
			glVertex2f(s.x-st,s.y+ct)
			glVertex2f(s.x-ct,s.y-st)
			glVertex2f(s.x+st,s.y-ct)
			glEnd()
			glColor3ubv(Wht)
		glColor3ubv(RGB[s.p])
		for a in GL_TRIANGLES,GL_LINE_LOOP:
			glBegin(a)
			glVertex2f(s.x,s.y)
			glVertex2f(s.x+r*cos(s.d-pi16),s.y+r*sin(s.d-pi16))
			glVertex2f(s.x+r*cos(s.d+pi16),s.y+r*sin(s.d+pi16))
			glEnd()
			glColor3ubv(Wht)
class Cannond(Cannon):
	def __init__(s,z):
		s.x=z.x
		s.y=z.y
		s.d=z.d
		s.p=z.p
		s.r=16
	def __call__(s):
		s.r-=1
		return not s.r or s.draw(s.r*1.5,cos1(T)*s.r,sin1(T)*s.r)
class CannonCannon:
	def __init__(s,x):
		Tl.append(s)
		s.x=x
		s.y=600
		s.h=s.p=0
		s.l=4
	def __call__(s):
		if s.y>400:s.y-=2
		if "C" in M:
			del M["C"]
			s.h=45
			s.p=not s.p
			s.l-=1
		if s.l>0:
			if not s.h:
				a=near(s.x,s.y)
				if a[0]<999 and a[2] and a[1] is not N1:msg("C")
			else:
				s.h-=1
				for a in NN:a.y=abs(a.y-(s.h>>2))
			if not T&15:F(Cannon(s.p,s.x,s.y,pi32,8,6))
		else:
			s.l-=2
			for a in range(8):Bul(2,s.x,s.y,pi28*a,8)
			if s.l==-80:return send
		ct=cos1(T)*(80+s.l)
		st=sin1(T)*(80+s.l)
		glColor4ub(RGB[s.p][0],0,RGB[s.p][2],655-s.y)
		for a in GL_QUADS,GL_LINE_LOOP:
			glBegin(a)
			glVertex2f(s.x+ct,s.y+st)
			glVertex2f(s.x-st,s.y+ct)
			glVertex2f(s.x-ct,s.y-st)
			glVertex2f(s.x+st,s.y-ct)
			glEnd()
			glColor3ubv(Wht)
class Gattle:
	die=lambda s:not Fd.add(Gattled(s))
	def __init__(s,p,x,y,d,v,t,V=4):
		s.p=p
		s.x=x
		s.y=y
		s.h=cos(d)*v
		s.v=sin(d)*v
		s.t=t
		s.T=s.d=0
		s.V=V
	def __call__(s):
		s.x+=s.h
		s.y+=s.v
		s.d+=pi19/s.t
		s.T+=1
		if not(-32<s.x<392 and -32<s.y<544):return send
		a=near(s.x,s.y)
		if a[0]<400 and a[2]:
			if a[1] is N1 and N1.p==s.p:Nut()
			return s.die()
		if not s.T%s.t:
			Bul(s.p,s.x,s.y,s.d,s.V)
			Bul(s.p,s.x,s.y,s.d+pi23,s.V)
			Bul(s.p,s.x,s.y,s.d-pi23,s.V)
		return s.draw(24.)
	def draw(s,r):
		glColor3ubv(RGB[s.p])
		for a in GL_TRIANGLES,GL_LINE_LOOP:
			glBegin(a)
			glVertex2f(s.x,s.y)
			glVertex2f(s.x+r*cos(s.d-pi16),s.y+r*sin(s.d-pi16))
			glVertex2f(s.x+r*cos(s.d+pi16),s.y+r*sin(s.d+pi16))
			glVertex2f(s.x,s.y)
			glVertex2f(s.x+r*cos(s.d+pi36),s.y+r*sin(s.d+pi36))
			glVertex2f(s.x+r*cos(s.d+pi56),s.y+r*sin(s.d+pi56))
			glVertex2f(s.x,s.y)
			glVertex2f(s.x+r*cos(s.d-pi56),s.y+r*sin(s.d-pi56))
			glVertex2f(s.x+r*cos(s.d-pi36),s.y+r*sin(s.d-pi36))
			glEnd()
			glColor3ubv(Wht)
class Gattled(Gattle):
	def __init__(s,z):
		s.p=z.p
		s.x=z.x
		s.y=z.y
		s.d=z.d
		s.r=24
	def __call__(s):
		s.r-=1
		return not s.r or s.draw(s.r)
class Complement:
	def __init__(s,x):
		Tl.append(s)
		s.p=2
		s.x=x
		s.y=-96
		s.d=pi12
		s.l=2
		s.h=s.s=0
		s.e=1.
	def __call__(s):
		if "O" in M:
			del M["O"]
			s.h=60
			s.l<<=1
			if s.l==16:s.s=3
		if s.s<2:
			s.y+=-2 if s.s else 16
			s.s+=s.y==(444 if s.s else 640)
		elif s.s==2:
			s.d+=pi/30
			a=near(s.x,s.y)
			if s.h:s.h-=1
			elif a[0]<999 and a[2] and a[1] is not N1:msg("O")
		else:
			s.e-=1.
			if s.e==60.:return send
		glColor3ubv(RGB[2])
		glBegin(GL_LINE_LOOP)
		for a in range(s.l):
			ca=cos(s.d+pi21*a/s.l)*s.e
			sa=sin(s.d+pi21*a/s.l)*s.e
			if T&3 and T%7 and s.s<3:Bad([getattr(ND[1.-Z0],"p",2),s.x+ca*99.,s.y+sa*99.,ca*8.,sa*8.])
			for a in range(9,99,3):glVertex2f(s.x+ca*a+getrandbits(3)-4,s.y+sa*a+getrandbits(3)-4)
		return glEnd()
class Laser(object):
	die=lambda s:not Fd.add(Laserd(s))
	def __init__(s,p,x,y,d):
		s.p=p
		s.x=x
		s.y=y
		s.t=d
		s.d=getnext(cycle(sin(pi19*a) for a in range(18)))
		s.l=0
		s.V=graphics.vertex_list(1,"v2f/stream","c3B")
		s.Vs=0
	def __call__(s):
		ha=N1.x-s.x
		va=N1.y-s.y
		h=abs(atan2(va,ha)-s.t)%pi21
		v=(ha**2+va**2)**.5
		if not(Z0 or pi12<h<pi23) and v<s.l and sin(h)*v<9:
			if s.p!=N1.p:
				send("\xEE")
				miss()
			else:atch()
		v=sin(s.t)
		h=cos(s.t)
		s.l+=20 if -20.<s.x+s.l*h<380. and -20.<s.y+s.l*v<532. else -20
		if s.l<0:return
		Vs=s.Vs
		s.Vs=3+s.l-s.l%3
		s.V.resize(s.Vs)
		for a in range(Vs,s.Vs,3):s.V.colors[a*3:a*3+9]=tuple((RGB if a&3 else BWB)[s.p])*3
		sd=s.d()
		for a in range(0,s.l,3):
			c=cos1(a)+sd
			ha=s.x+h*a-c*8.
			va=s.y+v*a-c*8.
			s.V.vertices[a*2:a*2+6]=ha+c*getrandbits(4),va+c*getrandbits(4),ha+c*getrandbits(4),va+c*getrandbits(4),ha+c*getrandbits(4),va+c*getrandbits(4)
		return s.V.draw(GL_TRIANGLES)
class Laserd(Laser):
	def __init__(s,z):
		s.p=z.p
		s.x=z.x
		s.y=z.y
		s.t=z.t
		s.h=cos(z.t)
		s.v=sin(z.t)
		s.d=z.d
		s.l=z.l
		s.V=z.V
		s.Vs=z.Vs
	def __call__(s):
		s.l-=30
		return s.l<0 or super(Laserd,s).__call__()
class LaserC:
	die=lambda s:(s.l.die(),Fd.add(LaserCd(s)))
	def __init__(s,p,x,y,d,v,D=None,a=0):
		s.l=Laser(p,x,y,d)
		s.p=RGB[p]
		s.x=x
		s.y=y
		s.h=cos(d if D is None else D)*v
		s.v=sin(d if D is None else D)*v
		s.a=a
		s.T=0
	def __call__(s):
		L=s.l
		L.x=s.x=s.x+s.h
		L.y=s.y=s.y+s.v
		s.T+=1
		if s.a:L.t+=ptdir(L.t,atan2(Y0-s.y,X0-s.x),pi/s.a)
		if not(-32<L.x<392 and -32<L.y<544):
			L.die()
			return send
		a=near(L.x,L.y)
		if a[0]<400 and a[2] and a[1] is N1 and L.p==N1.p:
			Nut()
			return s.die()
		L()
		return s.draw(cos1(s.T)*16.,sin1(s.T)*16.)
	def draw(s,ct,st):
		glColor3ubv(s.p)
		for a in GL_QUADS,GL_LINE_LOOP:
			glBegin(a)
			glVertex2f(s.x+ct,s.y+st)
			glVertex2f(s.x-st,s.y+ct)
			glVertex2f(s.x-ct,s.y-st)
			glVertex2f(s.x+st,s.y-ct)
			glEnd()
			glColor3ubv(Wht)
class LaserCd(LaserC):
	def __init__(s,z):
		s.x=z.l.x
		s.y=z.l.y
		s.p=RGB[z.l.p]
		s.r=16
		s.T=z.T
	def __call__(s):
		s.r-=1
		s.T+=1
		return not s.r or s.draw(cos1(s.T)*s.r,sin1(s.T)*s.r)
F=F()
Fd=set()
tcp=socket(AF_INET,SOCK_STREAM)
tcp.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
tcp.setsockopt(IPPROTO_TCP,TCP_NODELAY,1)
N1,N2=NN=(Node(120,256,0),Node(240,256,1))[::1-(getrandbits(1)<<1)]
hopo="",2000
L="Kikiki"
H=1
for a in chain(open("K.txt"),__import__("sys").argv[1:]):
	if a in "#":continue
	elif ":" in a:hopo=(a[:a.find(":")] or hopo[0] if a.find("::")==-1 else ""),int(a[a.rfind(":")+1:] or hopo[1])
	elif "." in a:hopo=a,hopo[1]
	elif a.isdigit():hopo=hopo[0],int(a)
	elif a[0] in "br":N1,N2=NN=(N1,N2)[::1-(((a[0]=="b")!=N1.p)<<1)]
	elif a[0]=="H":H=min(max(int(a[1:]),1),4)
	elif a[0]=="L":L=a[1:]
if hopo[0]:
	tcp.connect(hopo)
	L=ord(tcp.recv(1))
	N1,N2=NN=(N1,N2)[::1-((L>>7==N1.p)<<1)]
	H=(L>>5&3)+1
	L=tcp.recv(L&63)
else:
	tcp.bind(hopo)
	tcp.listen(1)
	tcp=tcp.accept()[0]
	tcp.setsockopt(IPPROTO_TCP,TCP_NODELAY,1)
	tcp.send("%c%s"%(N1.p<<7|H-1<<5|len(L),L))
recv=tcp.recv
send=tcp.send
ND=defaultdict(lambda:None,{0.:N1,1.:N2})
def Nut(s=N1,x=1):
	global N,Nap
	if s is N1:
		N+=[pi12,[(s.x,s.y)],1],
		Nap=x
L=__import__(L)
L.G.update(globals())
Time=L.Time
Back=L.Back
W.set_visible(True)
W.set_location(200+361*N1.p,50)
def draw(t):
	global T,Tl,Tlc,X0,Y0,Z0,hit,hit2,E,N,B,Bad,Nap
	W.clear()
	if Tl:
		Tlc+=1
		r=set(F.F.itervalues())
		Tl=[a for a in Tl if a in r]
	elif T-Tlc in Time:Time[T-Tlc]()
	Back(T,1-Z0 if N1.p else Z0)
	while select((tcp,),(),(),0)[0]:
		r=ord(recv(1))
		if r&0xF0==0xF0:
			N2.awds=r&1,r>>1&1,r>>2&1,r>>3&1
			N2.x=ord(recv(1))<<1
			N2.y=ord(recv(1))<<1
		elif r&0xF0==0xD0 or (r&0xF0==0xB0 and not N.append([pi12,[(N2.x,N2.y)],0])):
			getattr(F.F.pop((r&15)|ord(recv(1))<<4,None),"die",lambda:None)()
		elif r&0xF0==0xC0:
			a=recv(1+(r&15))
			M[a[0]]=a[1:]
		elif r==0xE2:E+=1
		elif r==0xE3:
			E=0
			N+=[pi12,[(N2.x,N2.y)],0],
		elif r==0xEE:miss()
		else:raise SystemExit("%.2X%s"%(r,recv(78)))
	if hit:
		for s in NN:
			s.x=180 if -16<s.x-180<16 else s.x-cmp(s.x,180)*12
			s.y=256 if -16<s.y-256<16 else s.y-cmp(s.y,256)*12
		hit=not(256==N1.y==N2.y and 180==N1.x==N2.x)
		B=[]
		hit2=30
	else:
		for s in NN:
			a=3+(s.awds[2]!=s.awds[0] and s.awds[1]!=s.awds[3])
			s.x+=(s.awds[2]-s.awds[0])*a
			s.y+=(s.awds[1]-s.awds[3])*a
			if s.x<0:s.x=0
			elif s.x>360:s.x=360
			if s.y<0:s.y=0
			elif s.y>511:s.y=511
		if hit2:
			hit2-=1
			if not hit2:Bad=B.append
	s=N1.y-N2.y
	if s:
		Z0+=s/((N1.x-N2.x)**2+s**2)**.5
		if Z0<0.:Z0=0.
		elif Z0>1.:Z0=1.
	X0=N1.x+(N2.x-N1.x)*Z0
	Y0=N1.y-s*Z0
	glBlendFunc(GL_SRC_ALPHA,GL_ONE)
	glBegin(GL_LINES)
	for s in NN:
		glColor3ubv(RGB[s.p])
		glVertex2i(s.x,s.y)
	glEnd()
	for s in NN:
		glBegin(GL_TRIANGLE_FAN)
		glColor3ubv(Blk)
		glVertex2i(s.x,s.y)
		glColor3ubv(RGB[s.p])
		for a in pi63v:glVertex2f(s.x+cos(a+T)*24.,s.y+sin(a+T)*24.)
		glEnd()
	glColor3ubv(Wht)
	glBegin(GL_TRIANGLE_FAN)
	glVertex2f(X0,Y0)
	glColor4ub(0,0,0,0)
	for a in pi63v:glVertex2f(X0+cos(a)*12.,Y0+sin(a)*12.)
	glEnd()
	r=[]
	s=ND[Z0]
	c=getnext(count())
	glBlendFunc(GL_SRC_ALPHA,GL_ZERO)
	glBegin(GL_QUADS)
	for a,b in enumerate(reversed(B)):
		b[1]+=b[3]
		b[2]+=b[4]
		r,x,y,v,h=b
		glColor3ubv(RGB[r])
		glVertex2f(x+7.,y)
		glVertex2f(x,y+7.)
		glVertex2f(x-7.,y)
		glVertex2f(x,y-7.)
		glColor3ubv(BWB[r])
		glVertex2f(x+4.,y)
		glVertex2f(x,y+4.)
		glVertex2f(x-4.,y)
		glVertex2f(x,y-4.)
		if not(-12.<x<372. and -12.<y<524.) or (s and r==s.p and (x-s.x)**2+(y-s.y)**2<400 and s==N1 and not atch()):del B[c()+~a]
		elif (x-X0)**2+(y-Y0)**2<49. and Z0<=.5 and r!=N1.p:
			send("\xEE")
			miss()
			break
	glEnd()
	for r in F.R:
		if r in F.F:del F.F[r]
	F.F.update(F._F)
	F._F.clear()
	for r in F:
		a=F[r]()
		if a:
			if a is not send:
				send("%c%c"%((0xB0 if Nap else 0xD0)|(r&15),r>>4))
				Nap=0
			del F[r]
	Fd.difference_update([r for r in Fd if r()])
	glBlendFunc(GL_ONE_MINUS_DST_COLOR,GL_ZERO)
	glBegin(GL_TRIANGLES)
	glColor3ubv(Wht)
	r=0
	for a in N:
		if a[0] is None:
			del a[1][0]
			if not a[1]:
				r+=1
				break
		else:
			if F:
				x=y=0
				for c in F:
					b=F[c].x-a[1][-1][0]
					c=F[c].y-a[1][-1][1]
					d=b**2+c**2+1
					x+=b/d
					y+=c/d
				a[0]+=ptdir(a[0],atan2(y,x),pi18)
			a[1]+=(a[1][-1][0]+cos(a[0])*12.,a[1][-1][1]+sin(a[0])*12.),
			if len(a[1])==45:a[0]=None
		d=1./len(a[1])
		c=0.
		for x,y in a[1]:
			c+=d
			glVertex2f(x+c*(getrandbits(5)-16),y+c*(getrandbits(5)-16))
			glVertex2f(x+c*(getrandbits(5)-16),y+c*(getrandbits(5)-16))
			glVertex2f(x+c*(getrandbits(5)-16),y+c*(getrandbits(5)-16))
	del N[:r]
	glEnd()
	glRecti(0,512,E*24,504)
	T+=1
	return W.flip()
clock.schedule_interval(draw,1/30)
recv(send(" "))
app.run()
send("\xEF")
